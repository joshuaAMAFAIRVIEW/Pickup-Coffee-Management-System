// Google Apps Script for Equipment Management
// Handles: Release logging, Return logging, and Bulk Import row deletion

function doPost(e) {
  try {
    // Parse incoming JSON data
    const data = JSON.parse(e.postData.contents);
    
    // Route to appropriate handler based on action
    if (data.action === 'deleteRows') {
      return deleteRowsHandler(data);
    }
    
    // Otherwise, handle release/return logging
    const type = data.type; // 'release' or 'return'
    const logData = data.data;
    
    // Get the active spreadsheet
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    
    // Get the appropriate sheet based on type
    let sheet;
    if (type === 'release') {
      sheet = ss.getSheetByName('Release');
    } else if (type === 'return') {
      sheet = ss.getSheetByName('Return');
    } else {
      throw new Error('Invalid type. Must be "release" or "return"');
    }
    
    if (!sheet) {
      throw new Error(`Sheet "${type}" not found`);
    }
    
    // Parse attributes JSON
    let attributes = {};
    try {
      attributes = JSON.parse(logData.attributes || '{}');
    } catch (err) {
      attributes = {};
    }
    
    // Extract serial number from attributes
    const serialNumber = attributes.S_N || attributes.s_n || 
                        attributes.SERIAL_NUMBER || attributes.serial_number || 
                        attributes.SN || attributes.sn || 'N/A';
    
    // Format other attributes (exclude serial number)
    const otherAttrs = Object.entries(attributes)
      .filter(([key]) => !['S_N', 's_n', 'SERIAL_NUMBER', 'serial_number', 'SN', 'sn'].includes(key))
      .map(([key, value]) => `${key}: ${value}`)
      .join(', ');
    
    // Prepare row data based on type
    let rowData;
    const timestamp = new Date();
    
    if (type === 'release') {
      rowData = [
        timestamp,
        logData.item_name || '',
        logData.category || '',
        logData.user_name || '',
        logData.username || '',
        logData.department || '',
        logData.region || '',
        logData.assigned_at || '',
        logData.item_condition || '',
        logData.notes || '',
        serialNumber,
        otherAttrs
      ];
      
      // Append to Release sheet
      sheet.appendRow(rowData);
      
    } else { // return - organize by condition
      const returnCondition = logData.return_condition || 'perfectly-working';
      const incidentPhotoUrl = logData.incident_photo_url || '';
      
      // Find the correct section based on return condition
      let targetRow;
      
      if (returnCondition === 'perfectly-working') {
        // Section 1: Perfectly Working (starts at row 2, after header at row 1)
        targetRow = findLastRowInSection(sheet, 1, 'PERFECTLY WORKING') + 1;
        
        // Create hyperlink for photo if URL exists
        const photoCell = incidentPhotoUrl ? `=HYPERLINK("${incidentPhotoUrl}", "View Photo")` : '';
        
        rowData = [
          timestamp,
          logData.item_name || '',
          logData.category || '',
          logData.user_name || '',
          logData.username || '',
          logData.department || '',
          logData.region || '',
          logData.assigned_at || '',
          logData.returned_at || '',
          serialNumber,
          otherAttrs,
          photoCell
        ];
        
      } else if (returnCondition === 'minor-issue') {
        // Section 2: Minor Dent/Problem
        targetRow = findSectionHeader(sheet, 'MINOR DENT');
        if (!targetRow) {
          // Create section if it doesn't exist
          const lastPerfectRow = findLastRowInSection(sheet, 1, 'PERFECTLY WORKING');
          targetRow = lastPerfectRow + 3; // Leave 2 empty rows
          sheet.getRange(targetRow, 1).setValue('=== MINOR DENT/PROBLEM ===');
          targetRow++;
          // Add headers
          sheet.getRange(targetRow, 1, 1, 12).setValues([[
            'Timestamp', 'Item Name', 'Category', 'User Name', 'Username', 
            'Department', 'Region', 'Assigned At', 'Returned At', 
            'Issue Details', 'Serial Number', 'Other Attributes'
          ]]);
        }
        targetRow = findLastRowInSection(sheet, targetRow, 'DAMAGED') + 1;
        rowData = [
          timestamp,
          logData.item_name || '',
          logData.category || '',
          logData.user_name || '',
          logData.username || '',
          logData.department || '',
          logData.region || '',
          logData.assigned_at || '',
          logData.returned_at || '',
          logData.damage_details || '',
          serialNumber,
          otherAttrs
        ];
        
      } else { // damaged
        // Section 3: Damaged
        targetRow = findSectionHeader(sheet, 'DAMAGED');
        if (!targetRow) {
          // Create section if it doesn't exist
          const lastMinorRow = findSectionHeader(sheet, 'MINOR DENT');
          if (!lastMinorRow) {
            const lastPerfectRow = findLastRowInSection(sheet, 1, 'PERFECTLY WORKING');
            targetRow = lastPerfectRow + 3;
          } else {
            targetRow = findLastRowInSection(sheet, lastMinorRow, 'DAMAGED') + 3;
          }
          sheet.getRange(targetRow, 1).setValue('=== DAMAGED ===');
          targetRow++;
          // Add headers
          sheet.getRange(targetRow, 1, 1, 13).setValues([[
            'Timestamp', 'Item Name', 'Category', 'User Name', 'Username', 
            'Department', 'Region', 'Assigned At', 'Returned At', 
            'Damage Details', 'Serial Number', 'Other Attributes', 'Incident Photo'
          ]]);
        }
        targetRow = sheet.getLastRow() + 1;
        
        // Create hyperlink for photo if URL exists
        const photoCell = incidentPhotoUrl ? `=HYPERLINK("${incidentPhotoUrl}", "View Photo")` : '';
        
        rowData = [
          timestamp,
          logData.item_name || '',
          logData.category || '',
          logData.user_name || '',
          logData.username || '',
          logData.department || '',
          logData.region || '',
          logData.assigned_at || '',
          logData.returned_at || '',
          logData.damage_details || '',
          serialNumber,
          otherAttrs,
          photoCell
        ];
      }
      
      // Insert row at target position
      sheet.insertRowAfter(targetRow - 1);
      sheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
    }
    
    // Return success response
    return ContentService.createTextOutput(JSON.stringify({
      success: true,
      message: `Data logged to ${type} sheet successfully`
    })).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    // Return error response
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// Helper function to find section header
function findSectionHeader(sheet, sectionName) {
  const data = sheet.getDataRange().getValues();
  for (let i = 0; i < data.length; i++) {
    if (data[i][0] && data[i][0].toString().includes(sectionName)) {
      return i + 1; // Return 1-indexed row
    }
  }
  return null;
}

// Helper function to find last row in a section
function findLastRowInSection(sheet, startRow, nextSectionName) {
  const data = sheet.getDataRange().getValues();
  for (let i = startRow; i < data.length; i++) {
    const cellValue = data[i][0] ? data[i][0].toString() : '';
    if (cellValue.includes('===') && cellValue.includes(nextSectionName)) {
      return i; // Return the row before the next section
    }
  }
  return sheet.getLastRow(); // Return last row if no next section found
}

// Test function (optional - for debugging)
function testPost() {
  const testData = {
    type: 'return',
    data: {
      item_name: 'Test Laptop',
      category: 'LAPTOP',
      user_name: 'John Doe',
      username: 'jdoe',
      department: 'IT',
      region: 'NCR',
      assigned_at: '2025-12-01 10:00:00',
      returned_at: '2025-12-02 14:30:00',
      return_condition: 'damaged',
      damage_details: 'Screen cracked',
      incident_photo_url: 'https://example.com/photo.jpg',
      attributes: '{"S_N":"TEST123","Brand":"Dell","Model":"XPS 15"}'
    }
  };
  
  const e = {
    postData: {
      contents: JSON.stringify(testData)
    }
  };
  
  const result = doPost(e);
  Logger.log(result.getContent());
}

// ========================================
// PART 2: BULK IMPORT ROW DELETION
// ========================================

function deleteRowsHandler(data) {
  try {
    const spreadsheetId = data.spreadsheetId;
    const sheetName = data.sheetName || 'Sheet1';
    const rowNumbers = data.rows; // Array of row numbers to delete (1-indexed)
    
    if (!Array.isArray(rowNumbers) || rowNumbers.length === 0) {
      throw new Error('No rows specified for deletion');
    }
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      throw new Error(`Sheet "${sheetName}" not found`);
    }
    
    // Sort rows in descending order to delete from bottom to top
    // This prevents row index shifting issues
    const sortedRows = rowNumbers.sort((a, b) => b - a);
    
    // Delete each row
    sortedRows.forEach(rowNum => {
      if (rowNum > 1) { // Don't delete header row
        sheet.deleteRow(rowNum);
      }
    });
    
    return ContentService.createTextOutput(JSON.stringify({
      success: true,
      message: `Deleted ${sortedRows.length} rows from ${sheetName}`
    })).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// Main handler - routes to appropriate function
function doGet(e) {
  return ContentService.createTextOutput(JSON.stringify({
    status: 'active',
    message: 'Equipment Management Apps Script is running',
    features: ['release-logging', 'return-logging', 'bulk-import-deletion']
  })).setMimeType(ContentService.MimeType.JSON);
}
